<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ì€í•˜ìˆ˜ ê´€ì¸¡ í™•ë¥  ê³„ì‚°ê¸° Pro Max</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    html, body { height:100%; }
    body{
      margin:0; padding:0;
      overflow:hidden; background:#000;
      position:fixed; width:100%;
      overscroll-behavior:none;
      -webkit-overflow-scrolling:auto;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
    }
    #map{ width:100vw; height:100vh; }

    #ui-panel{
      position:absolute; top:20px; right:20px; z-index:1000;
      background:rgba(30,30,30,0.85); backdrop-filter:blur(10px); color:white;
      padding:20px; border-radius:12px;
      box-shadow:0 4px 15px rgba(0,0,0,0.5); width:290px; max-height:90vh;
      overflow-y:auto; box-sizing:border-box;

      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      contain: layout paint;
      will-change: transform;
    }
    #ui-panel::-webkit-scrollbar{ width:8px; }
    #ui-panel::-webkit-scrollbar-thumb{ background:rgba(255,255,255,0.3); border-radius:4px; }

    .mobile-handle{
      display:none; width:40px; height:5px; background:rgba(255,255,255,0.4);
      border-radius:3px; margin:0 auto 15px auto; cursor:pointer;
      touch-action:none;
    }

    .ui-section{ margin-bottom:15px; }
    .ui-title{ font-size:14px; font-weight:900; margin-bottom:8px; color:#aaa; letter-spacing:0.2px; }

    select, input[type="date"], input[type="text"], input[type="number"], button{
      width:100%; padding:8px; margin-top:5px; background:rgba(255,255,255,0.1);
      color:white; border:1px solid #555; border-radius:8px; cursor:pointer; box-sizing:border-box;
    }
    input[type="text"], input[type="number"]{ cursor:text; }
    input::placeholder{ color:#888; }
    select option{ background:#333; }
    button:hover{ background:rgba(255,255,255,0.2); }

    .flex-row{ display:flex; gap:8px; }
    .flex-row input, .flex-row select { flex:2; margin-top:0; }
    .flex-row button{ flex:1; margin-top:0; }

    label{ cursor:pointer; display:flex; align-items:center; gap:8px; font-size:14px; }
    input[type="range"]{ width:100%; margin-top:5px; cursor:pointer; }

    .time-display-box{ text-align:center; font-size:18px; font-weight:900; color:#0df; margin-bottom:5px; }

    /* ===== Popup UI (ìŠ¤í¬ë¡¤ ë° ì•„ì½”ë””ì–¸) ===== */
    .leaflet-popup-content-wrapper, .leaflet-popup-tip{
      background:rgba(20,20,20,0.95) !important;
      backdrop-filter:blur(10px) !important;
      -webkit-backdrop-filter:blur(10px) !important;
      color:#ffffff !important;
      box-shadow:0 4px 15px rgba(0,0,0,0.8) !important;
      width:340px;
    }
    .leaflet-popup-content {
      max-height: 55vh;
      overflow-y: auto !important;
      overscroll-behavior: contain;
      padding-right: 6px !important;
      margin: 14px 12px 14px 16px !important;
    }
    .leaflet-popup-content::-webkit-scrollbar { width: 6px; }
    .leaflet-popup-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 4px; }
    .leaflet-popup-content hr{ border:0; border-top:1px solid rgba(255,255,255,0.15); margin:10px 0; }

    /* ì•„ì½”ë””ì–¸ ìŠ¤íƒ€ì¼ */
    .popup-details {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      margin-top: 8px;
      overflow: hidden;
    }
    .popup-summary {
      padding: 12px 10px;
      font-size: 13px;
      font-weight: 900;
      color: #fff;
      cursor: pointer;
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }
    .popup-summary::-webkit-details-marker { display: none; }
    .popup-summary::after {
      content: "â–¼";
      font-size: 10px;
      color: #aaa;
      transition: transform 0.2s;
    }
    .popup-details[open] .popup-summary::after {
      transform: rotate(180deg);
    }
    .popup-details-content {
      padding: 0 10px 12px 10px;
      border-top: 1px dashed rgba(255, 255, 255, 0.1);
      margin-top: 2px;
      padding-top: 10px;
    }

    .opacity-control{ display:flex; align-items:center; gap:10px; margin-top:5px; font-size:12px; }
    .opacity-label{ min-width:85px; }
    .notice-text{ font-size:11px; color:#999; margin-top:8px; line-height:1.45; word-break:keep-all; }

    .btn-simulate{
      background:rgba(0,255,100,0.2); border:1px solid #0f0; color:#0f0; font-weight:900;
      padding:12px; margin-top:10px; transition:0.3s; border-radius:10px;
    }
    .btn-simulate:hover:not(:disabled){ background:rgba(0,255,100,0.4); color:white; }
    .btn-simulate:disabled{ background:rgba(100,100,100,0.2); border-color:#555; color:#888; cursor:not-allowed; }

    .btn-capture{
      background:rgba(0,221,255,0.15); border:1px dashed #0df; color:#0df;
      font-weight:900; padding:10px; margin-top:12px; transition:0.3s; border-radius:10px;
      width:100%; box-sizing:border-box;
    }
    .btn-capture:hover{ background:rgba(0,221,255,0.35); color:#fff; }

    .btn-favorite{
      background:rgba(255,200,0,0.15); border:1px dashed #fd0; color:#fd0;
      font-weight:900; padding:10px; margin-top:8px; transition:0.3s; border-radius:10px;
      width:100%; box-sizing:border-box;
    }
    .btn-favorite:hover{ background:rgba(255,200,0,0.35); color:#fff; }

    #progress-container{ width:100%; height:6px; background:#333; border-radius:3px; margin-top:10px; overflow:hidden; display:none; }
    #progress-bar{ width:0%; height:100%; background:#0df; transition:width 0.2s ease-out; }

    .leaflet-control-locate{
      background:#1e1e1e; border:2px solid rgba(255,255,255,0.2); color:white; cursor:pointer;
      border-radius:4px; text-align:center; line-height:30px; font-size:18px; width:34px; height:34px;
      box-shadow:0 1px 5px rgba(0,0,0,0.65); transition:background 0.2s;
    }
    .leaflet-control-locate:hover{ background:#333; }

    .gonogo-box{ padding:10px; border-radius:12px; margin-bottom:8px; text-align:left; font-size:13px; line-height:1.6; }
    .gonogo-title{ font-size:18px; font-weight:1000; text-align:center; margin-bottom:8px; letter-spacing:0.5px; }
    .gonogo-item{ display:flex; justify-content:space-between; gap:10px; margin-bottom:4px; border-bottom:1px dashed rgba(255,255,255,0.1); padding-bottom:4px; }
    .gonogo-item:last-child{ border-bottom:none; padding-bottom:0; }
    .mw-window-box{ background:rgba(0,0,0,0.5); border:1px solid #444; padding:12px; border-radius:12px; }
    .timeline-legend{ display:flex; gap:6px; font-size:10px; justify-content:center; margin-top:6px; flex-wrap:wrap; }
    .legend-item{ display:flex; align-items:center; gap:4px; color:#ddd; }
    .legend-box{ width:10px; height:10px; border-radius:2px; }
    .cloud-detail{ font-size:11px; color:#aaa; font-weight:normal; }
    .warning-text{ color:#ff5555; font-weight:900; font-size:12px; }
    .safe-text{ color:#55ff55; font-size:12px; }
    .mode-badge{ display:inline-block; padding:4px 8px; border-radius:999px; font-size:11px; margin-top:6px; border:1px solid rgba(255,255,255,0.15); }
    .mode-weather{ background:rgba(0,255,100,0.15); color:#9f9; }
    .mode-no-weather{ background:rgba(255,200,0,0.15); color:#fd0; }

    #search-status{ display:none; margin-top:8px; font-size:11px; color:#0df; line-height:1.4; word-break:keep-all; }
    #search-results{ display:none; margin-top:10px; border:1px solid rgba(255,255,255,0.12); border-radius:12px; overflow:hidden; background:rgba(0,0,0,0.35); }
    .search-item{ padding:10px 10px; border-bottom:1px dashed rgba(255,255,255,0.12); cursor:pointer; transition:0.15s; }
    .search-item:last-child{ border-bottom:none; }
    .search-item:hover{ background:rgba(0,221,255,0.12); }
    .search-main{ font-size:12.5px; font-weight:900; color:#fff; line-height:1.2; margin-bottom:4px; }
    .search-sub{ font-size:10.5px; color:#aaa; line-height:1.3; }
    .search-meta{ margin-top:6px; display:flex; justify-content:space-between; font-size:10px; color:#888; gap:8px; }
    .btn-clear-results{
      margin-top:8px; padding:8px; border-radius:10px;
      background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.14);
      color:#ddd; font-size:12px;
    }
    .btn-clear-results:hover{ background:rgba(255,255,255,0.16); }

    .help-toggle{
      display:flex; align-items:center; justify-content:space-between; width:100%;
      padding:10px; border-radius:12px; background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.12); margin-top:6px; font-weight:1000;
    }
    .help-toggle:hover{ background:rgba(255,255,255,0.10); }
    .help-toggle .badge{
      font-size:11px; font-weight:900; padding:3px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.15); color:#0df; background:rgba(0,221,255,0.10);
    }
    .help-body{
      display:none; margin-top:10px; padding:12px; border-radius:12px;
      background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.12);
      font-size:12px; color:#ddd; line-height:1.55;
    }
    .help-body strong{ color:#fff; }
    .help-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .lp-chip{ display:flex; align-items:center; gap:8px; padding:8px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.04); font-size:11px; color:#ccc; }
    .lp-dot{ width:10px; height:10px; border-radius:50%; box-shadow:0 0 10px rgba(255,255,255,0.15); flex:0 0 10px; }
    .help-hr{ border:0; border-top:1px dashed rgba(255,255,255,0.14); margin:10px 0; }
    .help-tip{ font-size:11px; color:#aaa; margin-top:8px; }

    /* Compass / Navigation UI (panel + popup reuse) */
    .card{
      padding:10px; border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(0,0,0,0.35);
    }
    .row{ display:flex; gap:10px; align-items:center; }
    .row-between{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .muted{ color:#aaa; font-size:11px; line-height:1.35; }
    .tiny{ font-size:10px; color:#888; }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      font-size:12px; font-weight:900;
    }

    .toggle{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px; border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.04);
      margin-top:6px;
    }
    .toggle-left{ display:flex; flex-direction:column; gap:3px; min-width:0; }
    .toggle-title{ font-weight:1000; font-size:13px; color:#fff; }
    .toggle-sub{ font-size:11px; color:#aaa; line-height:1.35; }

    .switch{
      position:relative; width:48px; height:28px; flex:0 0 48px;
      border-radius:999px; background:rgba(255,255,255,0.12);
      border:1px solid rgba(255,255,255,0.12);
      cursor:pointer;
    }
    .switch::after{
      content:"";
      position:absolute; top:50%; left:4px;
      width:22px; height:22px; border-radius:50%;
      transform:translateY(-50%);
      background:rgba(255,255,255,0.85);
      transition:0.18s;
    }
    .switch.on{
      background:rgba(0,221,255,0.20);
      border-color:rgba(0,221,255,0.35);
    }
    .switch.on::after{ left:22px; background:#0df; }

    @media (max-width:768px){
      .mobile-handle{ display:block; }
      #ui-panel{
        top:auto; bottom:0; right:0; left:0; width:100vw;
        border-radius:20px 20px 0 0; max-height:70vh;
        transform:translateY(0);
        transition:transform 0.28s cubic-bezier(0.4,0,0.2,1);
        padding-bottom:30px;

        /* âœ… FIX: ëª¨ë°”ì¼ íŒ¨ë„ ìŠ¤í¬ë¡¤ í—ˆìš© */
        touch-action: pan-y;
      }
      /* âœ… FIX: í•¸ë“¤ë§Œ ë“œë˜ê·¸ ì œìŠ¤ì²˜ ì „ìš© */
      .mobile-handle{ touch-action:none; }

      #ui-panel.collapsed{
        transform:translateY(calc(100% - 54px));
        overflow:hidden;
        -webkit-overflow-scrolling:auto;
      }
      .leaflet-control-locate{ margin-left:10px !important; margin-top:10px !important; }
      .leaflet-popup-content-wrapper, .leaflet-popup-tip{ width:300px; }
    }
  </style>
</head>

<body>
  <div id="ui-panel" class="collapsed" aria-label="ì»¨íŠ¸ë¡¤ íŒ¨ë„">
    <div class="mobile-handle" id="mobile-toggle" aria-label="íŒ¨ë„ í•¸ë“¤"></div>

    <div class="ui-section">
      <div class="ui-title">â“ ì´ˆë³´ì ê°€ì´ë“œ</div>
      <button id="btn-help-toggle" class="help-toggle" type="button">
        <span>ê´‘í•´ì§€ë„ + ì€í•˜ìˆ˜ ë°©í–¥</span>
        <span class="badge" id="help-badge">OPEN</span>
      </button>
      <div id="help-body" class="help-body">
        <strong>1) ê´‘í•´ ì§€ë„(ë¹›ê³µí•´)</strong><br>
        <strong>ì–´ë‘ìš¸ìˆ˜ë¡ ì€í•˜ìˆ˜ëŠ” ì„ ëª…</strong>í•˜ê³  <strong>ë°ì„ìˆ˜ë¡ ì”»ê²¨ìš”</strong>.
        <div class="help-grid" aria-label="ê´‘í•´ ë²”ë¡€">
          <div class="lp-chip"><span class="lp-dot" style="background:#ffffff;"></span>ì•„ì£¼ ì–´ë‘ì›€ (ìµœìƒ)</div>
          <div class="lp-chip"><span class="lp-dot" style="background:#6ff;"></span>ì–´ë‘ì›€ (ì¶”ì²œ)</div>
          <div class="lp-chip"><span class="lp-dot" style="background:#0f0;"></span>ë³´í†µ (ì´¬ì˜ ê°€ëŠ¥)</div>
          <div class="lp-chip"><span class="lp-dot" style="background:#ff0;"></span>ë°ìŒ (ë³´ì • ê°ì˜¤)</div>
          <div class="lp-chip"><span class="lp-dot" style="background:#f80;"></span>ë§¤ìš° ë°ìŒ (ë¹„ì¶”)</div>
          <div class="lp-chip"><span class="lp-dot" style="background:#f00;"></span>ë„ì‹¬ê¸‰ (ê±°ì˜ ë¶ˆê°€)</div>
        </div>
        <hr class="help-hr">
        <strong>2) ì€í•˜ìˆ˜ ë°©í–¥</strong><br>
        ì§€ë„ ì•„ë¬´ ê³³ì´ë‚˜ ëˆ„ë¥´ë©´ íŒì—…ì— <strong>â€œì€í•˜ìˆ˜ ë°©í–¥(ë°©ìœ„ê°)â€</strong>ì´ ë‚˜ì˜µë‹ˆë‹¤.<br>
        â€¢ <strong>ë³´ë¼ìƒ‰ ì ì„ </strong>: í•´ë‹¹ ì‹œê°„ ì½”ì–´ ë°©í–¥<br>
        â€¢ <strong>ë‚˜ì¹¨ë°˜</strong>: ì¹´ë©”ë¼ë¥¼ ì–´ëŠ ìª½ìœ¼ë¡œ ëŒë¦´ì§€<br>
        â€¢ <strong>ì„ ëª…ë„ ì ìˆ˜</strong>: ì½”ì–´ ê³ ë„ + ë‹¬ë¹› + êµ¬ë¦„ + ê´‘í•´ë°©í–¥ ì¢…í•©
        <div class="help-tip">TIP: â€œì„ ëª…ë„ ì ìˆ˜â€ ë†’ì€ ì‹œê°„ëŒ€ â†’ â€œë°©í–¥â€ëŒ€ë¡œ í”„ë ˆì´ë°. ì´ˆë³´ì ì„±ê³µ ë£¨íŠ¸, ã„¹ã…‡.</div>
      </div>
    </div>

    <div class="ui-section">
      <div class="ui-title">ğŸ§­ ì‹¤ì‹œê°„ ë‚˜ì¹¨ë°˜(ì„¼ì„œ)</div>
      <div class="toggle">
        <div class="toggle-left">
          <div class="toggle-title">ì‹¤ì‹œê°„ ë°©í–¥ ì•ˆë‚´</div>
          <div class="toggle-sub">ëª¨ë°”ì¼ì€ ì„¼ì„œ ê¶Œí•œì´ í•„ìš”í•  ìˆ˜ ìˆì–´ìš”. (iOSëŠ” ë²„íŠ¼ ëˆ„ë¥¼ ë•Œë§Œ í—ˆìš©ë¨)</div>
        </div>
        <div class="switch" id="switch-compass" role="switch" aria-checked="false" tabindex="0"></div>
      </div>
      <div class="card" style="margin-top:10px;">
        <div class="row-between">
          <div class="chip">í˜„ì¬ í—¤ë”©</div>
          <div style="font-weight:1000; color:#0df;" id="heading-text">--Â°</div>
        </div>
        <div class="row-between" style="margin-top:8px;">
          <div class="chip">ì€í•˜ìˆ˜ê¹Œì§€</div>
          <div style="font-weight:1000; color:#ff77ff;" id="turn-text">--</div>
        </div>
        <div class="muted" style="margin-top:8px;" id="compass-status">OFF</div>
      </div>
    </div>

    <div class="ui-section">
      <div class="ui-title">ğŸ“· í”„ë ˆì´ë° ê°€ì´ë“œ(ë Œì¦ˆ í™”ê°)</div>
      <div class="card">
        <div class="flex-row">
          <select id="sensor-preset" style="flex:1.4;">
            <option value="ff">Full Frame (36x24)</option>
            <option value="aps15">APS-C (1.5x, 23.5x15.6)</option>
            <option value="aps16">APS-C (Canon 1.6x, 22.3x14.9)</option>
            <option value="mft">Micro 4/3 (17.3x13.0)</option>
          </select>
          <input id="focal-mm" type="number" min="1" step="1" value="16" style="flex:1;" />
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px;">
          <div class="card" style="padding:8px;">
            <div class="tiny">ìˆ˜í‰ í™”ê°</div>
            <div style="font-weight:1000; color:#0df;" id="fov-h">--Â°</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="tiny">ìˆ˜ì§ í™”ê°</div>
            <div style="font-weight:1000; color:#0df;" id="fov-v">--Â°</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="tiny">ëŒ€ê° í™”ê°</div>
            <div style="font-weight:1000; color:#0df;" id="fov-d">--Â°</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="tiny">í™˜ì‚°(FF eq)</div>
            <div style="font-weight:1000; color:#fd0;" id="fov-eq">--mm</div>
          </div>
        </div>
        <div class="muted" style="margin-top:10px;">
          íŒ: <b>ì€í•˜ìˆ˜ ì•„ì¹˜</b>ëŠ” ë³´í†µ â€œëŒ€ê° 100Â°ê¸‰â€ì´ ìœ ë¦¬(FF 14~16mm ëŠë‚Œ). ì½”ì–´ë§Œ ê°•í•˜ê²Œ ë½‘ìœ¼ë©´ 24~35mm ìª½ë„ ì¢‹ì•„ìš”.
        </div>
      </div>
    </div>

    <div class="ui-section">
      <div class="ui-title">ğŸŒ ì„¸ê³„ ì¥ì†Œ ê²€ìƒ‰</div>
      <div class="flex-row">
        <input type="text" id="search-input" placeholder="ë„ì‹œ, ì§€ì—­, ëª…ì†Œ ì…ë ¥..." autocomplete="off">
        <button id="btn-search">ê²€ìƒ‰</button>
      </div>
      <div id="search-status"></div>
      <div id="search-results"></div>
      <button id="btn-clear-results" class="btn-clear-results" style="display:none;">ê²€ìƒ‰ ê²°ê³¼ ë‹«ê¸°</button>
    </div>

    <div class="ui-section">
      <div class="ui-title">â­ ë‚´ ì¥ì†Œ (ì¦ê²¨ì°¾ê¸°)</div>
      <div class="flex-row">
        <select id="favorite-spots">
          <option value="">ì €ì¥ëœ ì¥ì†Œ ì„ íƒ...</option>
        </select>
        <button id="btn-del-fav" style="flex:0.6; background:rgba(255,50,50,0.2); border-color:#f55; color:#f55;">ì‚­ì œ</button>
      </div>
    </div>

    <div class="ui-section">
      <div class="ui-title">ğŸ—ºï¸ ì§€ë„ í…Œë§ˆ</div>
      <select id="map-theme">
        <option value="dark">ë‹¤í¬ ëª¨ë“œ (ê´€ì¸¡ ìµœì í™”)</option>
        <option value="satellite">ìœ„ì„± ì§€ë„ (ì§€í˜• í™•ì¸ìš©)</option>
        <option value="standard">ì¼ë°˜ ì§€ë„</option>
      </select>
    </div>

    <div class="ui-section">
      <div class="ui-title">âœ¨ ê´‘í•´ ì§€ë„</div>
      <label><input type="checkbox" id="light-pollution-toggle" checked> ì˜¤ë²„ë ˆì´ ì¼œê¸°</label>
      <div class="opacity-control">
        <span class="opacity-label">íˆ¬ëª…ë„ (<span id="opacity-val">60</span>%)</span>
        <input type="range" id="lp-opacity" min="0" max="1" step="0.1" value="0.6">
      </div>
    </div>

    <div class="ui-section">
      <div class="ui-title">ğŸ“… ê´€ì¸¡ ì˜ˆì •ì¼</div>
      <div class="flex-row">
        <input type="date" id="obs-date">
        <button id="btn-today">ì˜¤ëŠ˜</button>
      </div>
      <div class="notice-text">
        â€» ê¸°ìƒ ì˜ˆë³´(Open-Meteo)ëŠ” ìµœëŒ€ 14ì¼ê¹Œì§€ë§Œ ì œê³µë©ë‹ˆë‹¤. ì´í›„ ë‚ ì§œëŠ” ë‹¬ë¹›/ì½”ì–´/ê´‘í•´ë§Œ í‘œì‹œë©ë‹ˆë‹¤.
      </div>
      <div id="mode-badge" class="mode-badge mode-weather">MODE: Weather ON</div>
    </div>

    <div class="ui-section">
      <div class="ui-title">â° ê´€ì¸¡ ì‹œê°„</div>
      <div class="time-display-box" id="time-text">22:00</div>
      <input type="range" id="obs-time" min="0" max="23" value="22">
    </div>

    <div class="ui-section" id="best-date-section">
      <div class="ui-title">ğŸ”­ ë‹¤ìŒ ê´€ì¸¡ ìµœì ê¸° ì¶”ì²œ</div>
      <div class="card" id="best-date-box">ê³„ì‚° ì¤‘...</div>
      <button id="btn-simulate" class="btn-simulate">ğŸš€ ì„ íƒí•œ ë‚ ì§œì˜ ìµœì ì§€ ì°¾ê¸°</button>
      <div id="progress-container"><div id="progress-bar"></div></div>
      <div id="simulate-msg" class="notice-text" style="display:none; color:#0df;"></div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>

  <script>
    // =========================
    // Utilities
    // =========================
    function pad2(n){ return String(n).padStart(2,'0'); }
    function fmtYMD(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function getToday(){ return new Date(); }

    // âœ… FIX: ë¡œì»¬ ê¸°ì¤€ ë‚ ì§œ íŒŒì‹±(UTC í•˜ë£¨ ë°€ë¦¼ ë°©ì§€)
    function parseLocalYMD(dateStr){
      const [y,m,d] = dateStr.split('-').map(Number);
      return new Date(y, m-1, d); // local 00:00
    }

    function daysBetween(a, b){
      const aa = new Date(a.getFullYear(), a.getMonth(), a.getDate());
      const bb = new Date(b.getFullYear(), b.getMonth(), b.getDate());
      return Math.round((bb - aa) / 86400000);
    }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function norm360(d){ d = d % 360; if(d < 0) d += 360; return d; }
    function signedDeltaDeg(targetDeg, currentDeg){
      let d = norm360(targetDeg) - norm360(currentDeg);
      if(d > 180) d -= 360;
      if(d < -180) d += 360;
      return d;
    }
    function azToCompassKR(az){
      const dirs = ["ë¶","ë¶ë¶ë™","ë¶ë™","ë™ë¶ë™","ë™","ë™ë‚¨ë™","ë‚¨ë™","ë‚¨ë‚¨ë™","ë‚¨","ë‚¨ë‚¨ì„œ","ë‚¨ì„œ","ì„œë‚¨ì„œ","ì„œ","ì„œë¶ì„œ","ë¶ì„œ","ë¶ë¶ì„œ"];
      const idx = Math.round((norm360(az) / 22.5)) % 16;
      return dirs[idx];
    }
    function getMoonPhaseEmoji(phase) {
      if (phase < 0.06) return "ğŸŒ‘";
      if (phase < 0.19) return "ğŸŒ’";
      if (phase < 0.31) return "ğŸŒ“";
      if (phase < 0.44) return "ğŸŒ”";
      if (phase < 0.56) return "ğŸŒ•";
      if (phase < 0.69) return "ğŸŒ–";
      if (phase < 0.81) return "ğŸŒ—";
      if (phase < 0.94) return "ğŸŒ˜";
      return "ğŸŒ‘";
    }
    function escapeHtml(str){
      return String(str || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // =========================
    // Init date
    // =========================
    document.getElementById('obs-date').value = fmtYMD(getToday());

    // =========================
    // Help toggle (persist)
    // =========================
    (function initHelpToggle(){
      const btn = document.getElementById('btn-help-toggle');
      const body = document.getElementById('help-body');
      const badge = document.getElementById('help-badge');
      const KEY = "mw_help_open";
      const saved = localStorage.getItem(KEY);
      let open = (saved === null) ? true : (saved === "1");
      function apply(){
        body.style.display = open ? "block" : "none";
        badge.textContent = open ? "OPEN" : "CLOSED";
        badge.style.color = open ? "#0df" : "#aaa";
        badge.style.background = open ? "rgba(0,221,255,0.10)" : "rgba(255,255,255,0.06)";
      }
      apply();
      btn.addEventListener('click', () => {
        open = !open;
        localStorage.setItem(KEY, open ? "1" : "0");
        apply();
      });
    })();

    // =========================
    // Map init
    // =========================
    const map = L.map('map', { zoomControl: false }).setView([38.09, 127.07], 10);
    L.control.zoom({ position: 'topleft' }).addTo(map);

    const LocateControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-locate');
        container.innerHTML = 'ğŸ“';
        container.title = 'ë‚´ ìœ„ì¹˜ë¡œ ì´ë™';

        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.on(container, 'click', (e) => {
          L.DomEvent.stop(e);
          if (navigator.geolocation) {
            container.innerHTML = 'âŒ›';
            navigator.geolocation.getCurrentPosition(
              pos => {
                container.innerHTML = 'ğŸ“';
                const lat = pos.coords.latitude;
                const lng = pos.coords.longitude;
                map.setView([lat, lng], 11);
                analyzeData(lat, lng, "ë‚´ ìœ„ì¹˜ (í˜„ìœ„ì¹˜)");

                if(window.innerWidth <= 768) {
                  document.getElementById('ui-panel').classList.add('collapsed');
                }
              },
              err => {
                container.innerHTML = 'ğŸ“';
                alert('ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ì˜ ìœ„ì¹˜ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
              }
            );
          } else {
            alert('ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ìœ„ì¹˜ ì •ë³´ê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
          }
        });
        return container;
      }
    });
    map.addControl(new LocateControl());

    const standardLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' });
    const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '&copy; CARTO' });
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: '&copy; Esri' });
    let currentBaseLayer = darkLayer;
    currentBaseLayer.addTo(map);

    const lightPollutionLayer = L.tileLayer(
      'https://tiles.arcgis.com/tiles/b3fMqPOmotX6SV4k/arcgis/rest/services/ArtificialSkyBrightness/MapServer/tile/{z}/{y}/{x}',
      { opacity: 0.6, maxNativeZoom: 6, maxZoom: 19, zIndex: 10 }
    ).addTo(map);

    // =========================
    // Mobile bottom sheet swipe (tap to open + threshold)  âœ… FIX: ìŠ¤í¬ë¡¤/ë“œë˜ê·¸ ê³µì¡´
    // =========================
    (function initMobilePanelDrag(){
      const panel  = document.getElementById('ui-panel');
      const handle = document.getElementById('mobile-toggle');

      const PEEK = 54;
      const OPEN_THRESHOLD_RATIO = 0.75;
      const CLOSE_THRESHOLD_RATIO = 0.18;
      const TOP_DRAG_ZONE = 90;
      const TAP_MOVE_PX = 10;

      let startY = 0;
      let startX = 0;
      let startTranslate = 0;
      let currentTranslate = 0;
      let dragging = false;

      let tapStartX = 0, tapStartY = 0, tapActive = false;

      const isMobile = () => window.innerWidth <= 768;

      function getMaxTranslate(){
        const h = panel.getBoundingClientRect().height;
        return Math.max(0, h - PEEK);
      }
      function setTranslate(y){ panel.style.transform = `translateY(${y}px)`; }
      function clearTranslate(){ panel.style.transform = ''; }

      function lockPanelScroll(lock){
        if(lock){
          panel.style.overflow = 'hidden';
          panel.style.webkitOverflowScrolling = 'auto';
        }else{
          panel.style.overflow = '';
          panel.style.webkitOverflowScrolling = 'touch';
        }
      }

      function expand(){
        panel.classList.remove('collapsed');
        panel.style.transition = '';
        lockPanelScroll(false);
        clearTranslate();
      }
      function collapse(){
        panel.classList.add('collapsed');
        panel.style.transition = '';
        lockPanelScroll(false);
        clearTranslate();
        panel.scrollTop = 0;
      }
      function isCollapsed(){ return panel.classList.contains('collapsed'); }

      function withinTopZone(clientY){
        const rect = panel.getBoundingClientRect();
        return clientY <= (rect.top + TOP_DRAG_ZONE);
      }

      function canStartDrag(target, clientY){
        if(!isMobile()) return false;
        if(isCollapsed()) return true;
        const isHandle = handle && (target === handle || handle.contains(target));
        const atTop = panel.scrollTop <= 0;
        return (isHandle || withinTopZone(clientY)) && atTop;
      }

      // âœ… FIX: ë“œë˜ê·¸ ì¤‘ì¼ ë•Œë§Œ preventDefault (ìŠ¤í¬ë¡¤ ë§‰í˜ ì œê±°)
      document.addEventListener('touchmove', (e) => {
        if(!isMobile()) return;
        if(dragging && e.cancelable) e.preventDefault();
      }, { passive:false });

      function onTouchStart(e){
        if(!isMobile()) return;
        const t = e.touches[0];
        startY = t.clientY;
        startX = t.clientX;

        if(isCollapsed()){
          tapActive = true;
          tapStartX = startX;
          tapStartY = startY;
        } else {
          tapActive = false;
        }

        if(!canStartDrag(e.target, t.clientY)) return;

        dragging = true;
        panel.style.transition = 'none';

        const maxT = getMaxTranslate();
        startTranslate = isCollapsed() ? maxT : 0;
        currentTranslate = startTranslate;

        lockPanelScroll(true);
        setTranslate(currentTranslate);

        if(e.cancelable) e.preventDefault();
      }

      function onTouchMove(e){
        if(!isMobile()) return;
        const t = e.touches[0];
        const dy = t.clientY - startY;
        const dx = t.clientX - startX;

        if(tapActive && (Math.abs(dx) > TAP_MOVE_PX || Math.abs(dy) > TAP_MOVE_PX)){
          tapActive = false;
        }
        if(!dragging) return;

        const maxT = getMaxTranslate();
        if(!isCollapsed() && dy < 0){
          dragging = false;
          panel.style.transition = '';
          lockPanelScroll(false);
          clearTranslate();
          return;
        }

        let next = startTranslate + dy;
        next = clamp(next, 0, maxT);

        currentTranslate = next;
        setTranslate(currentTranslate);

        if(e.cancelable) e.preventDefault();
      }

      function onTouchEnd(){
        if(!isMobile()) return;

        if(isCollapsed() && tapActive){
          expand();
          tapActive = false;
          return;
        }

        if(!dragging) return;

        dragging = false;
        panel.style.transition = '';
        lockPanelScroll(false);

        const maxT = getMaxTranslate();
        if(isCollapsed()){
          const openThreshold = maxT * OPEN_THRESHOLD_RATIO;
          if(currentTranslate < openThreshold) expand();
          else collapse();
        } else {
          const closeThreshold = maxT * CLOSE_THRESHOLD_RATIO;
          if(currentTranslate > closeThreshold) collapse();
          else expand();
        }
        tapActive = false;
      }

      panel.addEventListener('touchstart', onTouchStart, { passive:false });
      panel.addEventListener('touchmove',  onTouchMove,  { passive:false });
      panel.addEventListener('touchend',   onTouchEnd,   { passive:true  });
      panel.addEventListener('touchcancel',onTouchEnd,   { passive:true  });

      handle.addEventListener('click', () => { if(!isMobile()) return; isCollapsed() ? expand() : collapse(); });
      handle.addEventListener('touchend', () => { if(!isMobile()) return; isCollapsed() ? expand() : collapse(); }, { passive:true });

      window.addEventListener('resize', () => {
        panel.style.transition = '';
        lockPanelScroll(false);
        clearTranslate();
      });
    })();

    // =========================
    // Favorites
    // =========================
    function loadFavorites() {
      const sel = document.getElementById('favorite-spots');
      sel.innerHTML = '<option value="">ì €ì¥ëœ ì¥ì†Œ ì„ íƒ...</option>';
      let favs = JSON.parse(localStorage.getItem('mw_fav_spots') || '[]');
      favs.forEach((f, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = f.name;
        sel.appendChild(opt);
      });
    }
    window.saveFavorite = function(ev, lat, lng, defaultName) {
      if (ev) { ev.preventDefault(); ev.stopPropagation(); }
      let favs = JSON.parse(localStorage.getItem('mw_fav_spots') || '[]');
      let name = prompt("ì €ì¥í•  ì¥ì†Œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:", defaultName || 'ìƒˆë¡œìš´ ê´€ì¸¡ì§€');
      if (!name) return;
      favs.push({ name: name, lat: lat, lng: lng });
      localStorage.setItem('mw_fav_spots', JSON.stringify(favs));
      loadFavorites();
      alert(`'${name}'ì´(ê°€) ì¦ê²¨ì°¾ê¸°ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    };
    document.getElementById('favorite-spots').addEventListener('change', function(e) {
      const val = e.target.value;
      if (val === "") return;
      let favs = JSON.parse(localStorage.getItem('mw_fav_spots') || '[]');
      const spot = favs[val];
      if (spot) {
        map.setView([spot.lat, spot.lng], 11);
        analyzeData(spot.lat, spot.lng, spot.name);
        if(window.innerWidth <= 768) document.getElementById('ui-panel').classList.add('collapsed');
      }
    });
    document.getElementById('btn-del-fav').addEventListener('click', function() {
      const sel = document.getElementById('favorite-spots');
      const val = sel.value;
      if (val === "") { alert("ëª©ë¡ì—ì„œ ì‚­ì œí•  ì¥ì†Œë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”."); return; }
      let favs = JSON.parse(localStorage.getItem('mw_fav_spots') || '[]');
      const name = favs[val].name;
      if(confirm(`'${name}'ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
        favs.splice(val, 1);
        localStorage.setItem('mw_fav_spots', JSON.stringify(favs));
        loadFavorites();
        map.closePopup();
      }
    });
    loadFavorites();

    // =========================
    // Search (Nominatim)
    // =========================
    const elSearchStatus  = document.getElementById('search-status');
    const elSearchResults = document.getElementById('search-results');
    const btnClearResults = document.getElementById('btn-clear-results');
    let searchAbort = null;
    let lastSearchTs = 0;

    function setSearchStatus(text, color="#0df", show=true){
      elSearchStatus.style.display = show ? 'block' : 'none';
      elSearchStatus.style.color = color;
      elSearchStatus.textContent = text || "";
    }
    function clearSearchUI(){
      elSearchResults.innerHTML = "";
      elSearchResults.style.display = "none";
      btnClearResults.style.display = "none";
      setSearchStatus("", "#0df", false);
    }
    btnClearResults.addEventListener('click', clearSearchUI);

    function renderSearchResults(items){
      if(!items || items.length === 0){
        elSearchResults.innerHTML = "";
        elSearchResults.style.display = "none";
        btnClearResults.style.display = "none";
        return;
      }
      elSearchResults.innerHTML = items.map((it, idx) => {
        const main = (it.display_name || "").split(",")[0] || "ê²°ê³¼";
        const sub = (it.display_name || "").replace(main + ",", "").trim();
        const lat = parseFloat(it.lat).toFixed(4);
        const lng = parseFloat(it.lon).toFixed(4);
        return `
          <div class="search-item" data-idx="${idx}">
            <div class="search-main">ğŸ“ ${escapeHtml(main)}</div>
            <div class="search-sub">${escapeHtml(sub || it.display_name || "")}</div>
            <div class="search-meta">
              <span>${escapeHtml(it.type || it.class || "location")}</span>
              <span>${lat}, ${lng}</span>
            </div>
          </div>
        `;
      }).join("");

      elSearchResults.style.display = "block";
      btnClearResults.style.display = "block";

      elSearchResults.onclick = (e) => {
        const item = e.target.closest('.search-item');
        if(!item) return;
        const idx = parseInt(item.dataset.idx, 10);
        const it = items[idx];
        if(!it) return;
        const lat = parseFloat(it.lat);
        const lng = parseFloat(it.lon);
        const displayName = (it.display_name || "").split(',')[0] || "ì„ íƒí•œ ìœ„ì¹˜";

        map.setView([lat, lng], 11);
        analyzeData(lat, lng, displayName);

        clearSearchUI();
        if(window.innerWidth <= 768) document.getElementById('ui-panel').classList.add('collapsed');
      };
    }

    async function performSearch() {
      const query = document.getElementById('search-input').value.trim();
      if (!query) return;
      const now = Date.now();
      if (now - lastSearchTs < 350) return;
      lastSearchTs = now;

      const btn = document.getElementById('btn-search');
      const originalText = btn.innerText;
      btn.innerText = "â³...";
      btn.disabled = true;
      setSearchStatus("ê²€ìƒ‰ ì¤‘...", "#0df", true);

      if (searchAbort) searchAbort.abort();
      searchAbort = new AbortController();

      try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&limit=5&accept-language=ko&q=${encodeURIComponent(query)}`;
        const response = await fetch(url, { signal: searchAbort.signal, headers: { "Accept": "application/json" } });
        if (!response.ok) {
          if (response.status === 429) setSearchStatus("ìš”ì²­ì´ ë„ˆë¬´ ë§ì•„ìš”(429). ì ì‹œ í›„ ë‹¤ì‹œ ê²€ìƒ‰í•´ì£¼ì„¸ìš”.", "#fd0", true);
          else setSearchStatus(`ê²€ìƒ‰ ì‹¤íŒ¨(${response.status}). ë„¤íŠ¸ì›Œí¬/ì •ì±… ì´ìŠˆì¼ ìˆ˜ ìˆì–´ìš”.`, "#f55", true);
          renderSearchResults([]);
          return;
        }
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
          setSearchStatus(`ê²€ìƒ‰ ê²°ê³¼ ${data.length}ê°œ (í´ë¦­í•˜ì—¬ ì´ë™)`, "#0df", true);
          renderSearchResults(data);
        } else {
          setSearchStatus("ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ í‚¤ì›Œë“œë¥¼ ì¨ë³´ì„¸ìš”.", "#fd0", true);
          renderSearchResults([]);
        }
      } catch (error) {
        if (error && error.name === "AbortError") return;
        console.error("Geocoding error:", error);
        setSearchStatus("ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ë„¤íŠ¸ì›Œí¬/ì •ì±… ì´ìŠˆ ê°€ëŠ¥)", "#f55", true);
        renderSearchResults([]);
      } finally {
        btn.innerText = originalText;
        btn.disabled = false;
      }
    }
    document.getElementById('btn-search').addEventListener('click', performSearch);
    document.getElementById('search-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') performSearch(); });

    // =========================
    // Weather window UI
    // =========================
    function isWithinWeatherWindow(dateStr){
      const sel = parseLocalYMD(dateStr);
      const diff = daysBetween(getToday(), sel);
      return diff >= 0 && diff <= 14;
    }
    function updateWeatherModeUI(){
      const dateStr = document.getElementById('obs-date').value;
      const badge = document.getElementById('mode-badge');
      const btn = document.getElementById('btn-simulate');
      const within = isWithinWeatherWindow(dateStr);

      if(within){
        badge.textContent = "MODE: Weather ON";
        badge.classList.remove('mode-no-weather');
        badge.classList.add('mode-weather');
        btn.disabled = false;
        btn.textContent = "ğŸš€ ì„ íƒí•œ ë‚ ì§œì˜ ìµœì ì§€ ì°¾ê¸°";
        const msg = document.getElementById('simulate-msg');
        msg.style.display = 'none';
      } else {
        badge.textContent = "MODE: Weather OFF (14ì¼ ì´í›„)";
        badge.classList.remove('mode-weather');
        badge.classList.add('mode-no-weather');
        btn.disabled = true;
        btn.textContent = "ğŸŒ™ 14ì¼ ì´í›„: ë‚ ì”¨ ì—†ì´ ë¶„ì„";
        const msg = document.getElementById('simulate-msg');
        msg.style.display = 'block';
        msg.style.color = '#fd0';
        msg.innerText = 'âš ï¸ ì„ íƒ ë‚ ì§œê°€ 14ì¼ ì´í›„ë¼ ì „êµ­ ìµœì ì§€ ì‹œë®¬ë ˆì´ì…˜ì€ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.';
      }
    }

    // =========================
    // Lens FOV / framing guide
    // =========================
    const SENSOR = {
      ff:   { w:36.0, h:24.0, crop:1.0, name:"Full Frame" },
      aps15:{ w:23.5, h:15.6, crop:1.5, name:"APS-C 1.5x" },
      aps16:{ w:22.3, h:14.9, crop:1.6, name:"APS-C 1.6x" },
      mft:  { w:17.3, h:13.0, crop:2.0, name:"Micro 4/3" },
    };

    function fovDeg(sensorSizeMm, focalMm){
      const rad = 2 * Math.atan(sensorSizeMm / (2 * focalMm));
      return rad * 180 / Math.PI;
    }
    function updateFovUI(){
      const preset = document.getElementById('sensor-preset').value;
      const f = parseFloat(document.getElementById('focal-mm').value || "0");
      const s = SENSOR[preset] || SENSOR.ff;

      if(!isFinite(f) || f <= 0){
        document.getElementById('fov-h').textContent = "--Â°";
        document.getElementById('fov-v').textContent = "--Â°";
        document.getElementById('fov-d').textContent = "--Â°";
        document.getElementById('fov-eq').textContent = "--mm";
        return;
      }

      const diag = Math.sqrt(s.w*s.w + s.h*s.h);
      const fh = fovDeg(s.w, f);
      const fv = fovDeg(s.h, f);
      const fd = fovDeg(diag, f);
      const eq = (f * s.crop);

      document.getElementById('fov-h').textContent = `${fh.toFixed(1)}Â°`;
      document.getElementById('fov-v').textContent = `${fv.toFixed(1)}Â°`;
      document.getElementById('fov-d').textContent = `${fd.toFixed(1)}Â°`;
      document.getElementById('fov-eq').textContent = `${eq.toFixed(1)}mm`;
    }
    document.getElementById('sensor-preset').addEventListener('change', updateFovUI);
    document.getElementById('focal-mm').addEventListener('input', updateFovUI);
    updateFovUI();

    function getFovSummaryHtml(){
      const preset = document.getElementById('sensor-preset').value;
      const f = parseFloat(document.getElementById('focal-mm').value || "0");
      const s = SENSOR[preset] || SENSOR.ff;
      if(!isFinite(f) || f <= 0) return `<div class="muted">í”„ë ˆì´ë° ê°€ì´ë“œ: ê°’ì´ ë¹„ì–´ìˆì–´ìš”.</div>`;
      const diag = Math.sqrt(s.w*s.w + s.h*s.h);
      const fh = fovDeg(s.w, f);
      const fv = fovDeg(s.h, f);
      const fd = fovDeg(diag, f);
      const eq = (f * s.crop);
      return `
        <div class="card" style="margin-top:0;">
          <div class="row-between">
            <div style="font-weight:1000;">ğŸ“· í”„ë ˆì´ë° (${escapeHtml(s.name)} / ${f}mm)</div>
            <div class="tiny">FF eq ${eq.toFixed(1)}mm</div>
          </div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px;">
            <div class="card" style="padding:8px;">
              <div class="tiny">ìˆ˜í‰</div>
              <div style="font-weight:1000; color:#0df;">${fh.toFixed(1)}Â°</div>
            </div>
            <div class="card" style="padding:8px;">
              <div class="tiny">ìˆ˜ì§</div>
              <div style="font-weight:1000; color:#0df;">${fv.toFixed(1)}Â°</div>
            </div>
            <div class="card" style="padding:8px;">
              <div class="tiny">ëŒ€ê°</div>
              <div style="font-weight:1000; color:#0df;">${fd.toFixed(1)}Â°</div>
            </div>
            <div class="card" style="padding:8px;">
              <div class="tiny">ì¶”ì²œ</div>
              <div style="font-weight:1000; color:#fd0;">${fd >= 90 ? "ì•„ì¹˜ ìœ ë¦¬" : (fd >= 65 ? "ì½”ì–´+ì£¼ë³€" : "ì½”ì–´ ì§‘ì¤‘")}</div>
            </div>
          </div>
          <div class="muted" style="margin-top:8px;">
            â€¢ ì•„ì¹˜: ëŒ€ê° 90~110Â°ëŒ€(FF 14~16mm ëŠë‚Œ)<br>
            â€¢ ì½”ì–´: ëŒ€ê° 60~85Â°ëŒ€(FF 20~35mm ëŠë‚Œ)
          </div>
        </div>
      `;
    }

    // =========================
    // Compass sensor (real-time heading)
    // =========================
    const switchCompass = document.getElementById('switch-compass');
    const headingText = document.getElementById('heading-text');
    const turnText = document.getElementById('turn-text');
    const compassStatus = document.getElementById('compass-status');

    let compassEnabled = false;
    let lastHeadingDeg = null;
    let lastMWAzDeg = null;
    let orientationHandler = null;
    let compassEvtName = 'deviceorientation';

    function updateCompassPanelUI(){
      switchCompass.classList.toggle('on', compassEnabled);
      switchCompass.setAttribute('aria-checked', compassEnabled ? 'true' : 'false');

      headingText.textContent = (lastHeadingDeg == null) ? "--Â°" : `${Math.round(lastHeadingDeg)}Â°`;
      if(lastHeadingDeg == null || lastMWAzDeg == null){
        turnText.textContent = "--";
      } else {
        const d = signedDeltaDeg(lastMWAzDeg, lastHeadingDeg);
        const abs = Math.round(Math.abs(d));
        if(abs < 5) turnText.textContent = "ì •ë©´ âœ…";
        else turnText.textContent = (d > 0) ? `ì˜¤ë¥¸ìª½ ${abs}Â°` : `ì™¼ìª½ ${abs}Â°`;
      }

      if(!compassEnabled) {
        compassStatus.textContent = "OFF";
        compassStatus.style.color = "#aaa";
      } else {
        compassStatus.textContent = (lastHeadingDeg == null)
          ? "ON (ì„¼ì„œ ëŒ€ê¸° ì¤‘...)"
          : "ON (ë‚´ë¹„ê²Œì´ì…˜ì²˜ëŸ¼ ì•ˆë‚´ ì¤‘)";
        compassStatus.style.color = "#0df";
      }
    }

    function getScreenOrientationAngle(){
      const so = screen.orientation && typeof screen.orientation.angle === 'number' ? screen.orientation.angle : null;
      if(so != null) return so;
      const w = window.orientation;
      if(typeof w === 'number') return w;
      return 0;
    }

    function headingFromDeviceOrientationEvent(e){
      if(typeof e.webkitCompassHeading === 'number') {
        return norm360(e.webkitCompassHeading);
      }
      if(typeof e.alpha !== 'number') return null;
      const alpha = e.alpha;
      let heading = 360 - alpha;
      const screenAngle = getScreenOrientationAngle();
      heading = heading + screenAngle;
      return norm360(heading);
    }

    async function enableCompass(){
      compassEnabled = true;
      lastHeadingDeg = null;

      try{
        if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
          const res = await DeviceOrientationEvent.requestPermission();
          if(res !== 'granted'){
            compassEnabled = false;
            compassStatus.textContent = "ê¶Œí•œ ê±°ë¶€ë¨ (iOS ì„¤ì •/ê¶Œí•œ í™•ì¸)";
            compassStatus.style.color = "#f55";
            updateCompassPanelUI();
            return;
          }
        }
      }catch(err){
        compassEnabled = false;
        compassStatus.textContent = "ì„¼ì„œ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨";
        compassStatus.style.color = "#f55";
        updateCompassPanelUI();
        return;
      }

      orientationHandler = (e) => {
        const h = headingFromDeviceOrientationEvent(e);
        if(h == null) return;
        if(lastHeadingDeg == null){
          lastHeadingDeg = h;
        } else {
          const d = signedDeltaDeg(h, lastHeadingDeg);
          lastHeadingDeg = norm360(lastHeadingDeg + d * 0.25);
        }
        updateCompassPanelUI();
        updatePopupNavIfAny();
      };

      // âœ… FIX: absolute ì§€ì› ìš°ì„ 
      compassEvtName = ('ondeviceorientationabsolute' in window) ? 'deviceorientationabsolute' : 'deviceorientation';
      window.addEventListener(compassEvtName, orientationHandler, true);
      updateCompassPanelUI();
    }

    function disableCompass(){
      compassEnabled = false;
      if(orientationHandler){
        window.removeEventListener(compassEvtName, orientationHandler, true);
        orientationHandler = null;
      }
      lastHeadingDeg = null;
      updateCompassPanelUI();
      updatePopupNavIfAny();
    }

    async function toggleCompass(){
      if(compassEnabled) disableCompass();
      else await enableCompass();
    }

    switchCompass.addEventListener('click', toggleCompass);
    switchCompass.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleCompass(); }
    });
    updateCompassPanelUI();

    // =========================
    // Astro logic
    // =========================
    function getGalacticCorePosition(date, lat, lng) {
      const RA = 266.4168, Dec = -29.0078, rad = Math.PI / 180;
      const jd = (date.getTime() / 86400000) + 2440587.5;
      const d = jd - 2451545.0;
      let LST = (280.46061837 + 360.98564736629 * d + lng) % 360;
      if (LST < 0) LST += 360;
      let HA = LST - RA;
      if (HA < 0) HA += 360;

      const HA_rad = HA * rad, Dec_rad = Dec * rad, Lat_rad = lat * rad;
      const sinAlt = Math.sin(Dec_rad) * Math.sin(Lat_rad) + Math.cos(Dec_rad) * Math.cos(Lat_rad) * Math.cos(HA_rad);
      const sinAltC = clamp(sinAlt, -1, 1);
      const altRad = Math.asin(sinAltC);
      const alt = altRad / rad;
      const cosAlt = Math.cos(altRad);

      let cosAz = (Math.sin(Dec_rad) - Math.sin(Lat_rad) * sinAltC) / (Math.cos(Lat_rad) * (cosAlt || 1e-9));
      cosAz = clamp(cosAz, -1, 1);
      let az = Math.acos(cosAz) / rad;
      if (Math.sin(HA_rad) > 0) az = 360 - az;
      return { altitude: alt, azimuth: az };
    }

    function evaluateMoonImpact(date, lat, lng, gcAzimuth) {
      const illum = SunCalc.getMoonIllumination(date);
      const moonIllum = Math.round(illum.fraction * 100);
      const moonEmoji = getMoonPhaseEmoji(illum.phase);

      const mPos = SunCalc.getMoonPosition(date, lat, lng);
      const mAlt = mPos.altitude * 180 / Math.PI;
      let mAz = (mPos.azimuth * 180 / Math.PI) + 180;

      let azDiff = Math.abs(mAz - gcAzimuth);
      if (azDiff > 180) azDiff = 360 - azDiff;

      let isSafe = false, statusColor = "", statusText = "", timelineColor = "";
      if (mAlt < 0) {
        isSafe = true; statusColor = "#0df"; statusText = `ğŸŸ¢ ì™„ë²½ ì°¨ë‹¨ (-${Math.abs(Math.round(mAlt))}Â°)`; timelineColor = "#fd0";
      } else if (moonIllum < 15) {
        isSafe = true; statusColor = "#0df"; statusText = `ğŸŸ¢ ì˜í–¥ ë¯¸ë¯¸ (${moonIllum}%)`; timelineColor = "#fd0";
      } else {
        if (azDiff < 40 && mAlt > 0) { statusColor = "#f55"; statusText = `ğŸ”´ ì½”ì–´ ë°©í•´ (ë‹¬ ê²¹ì¹¨!)`; timelineColor = "#f00"; }
        else if (mAlt > 10) { statusColor = "#f55"; statusText = `ğŸ”´ ë‹¬ë¹› ì”»ê¹€ (ê³ ë„ ${Math.round(mAlt)}Â°)`; timelineColor = "#635"; }
        else { statusColor = "#fa0"; statusText = `ğŸŸ¡ ì €ê³ ë„ ê°„ì„­ ì£¼ì˜`; timelineColor = "#c60"; }
      }
      return { isSafe, statusColor, statusText, timelineColor, moonIllum, mAlt, azDiff, moonEmoji };
    }

    function evaluateCloudImpact(cLow, cMid, cHigh, cTotal) {
      let isSafe = false, statusColor = "", statusText = "";
      if (cHigh >= 20) { isSafe = false; statusColor = "#f55"; statusText = `ğŸ”´ ìƒì¸µìš´ ì¹˜ëª…ì `; }
      else if (cTotal >= 35) { isSafe = false; statusColor = "#f55"; statusText = `ğŸ”´ êµ¬ë¦„ ë§ìŒ (ê´€ì¸¡ ë¶ˆê°€)`; }
      else if (cTotal > 15 || cHigh > 10) { isSafe = true; statusColor = "#fa0"; statusText = `ğŸŸ¡ ì•½ê°„ íë¦¼`; }
      else { isSafe = true; statusColor = "#0df"; statusText = `ğŸŸ¢ ì¾Œì²­`; }
      return { isSafe, statusColor, statusText };
    }

    function evaluateDirectionalLightPollution(lat, lng, coreAzimuth) {
      const seoulLat = 37.5665, seoulLng = 126.9780;
      const R = 6371, dLat = (seoulLat - lat) * Math.PI / 180, dLon = (seoulLng - lng) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat * Math.PI / 180) * Math.cos(seoulLat * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
      const distance = R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)));

      const y = Math.sin(dLon) * Math.cos(seoulLat * Math.PI / 180);
      const x = Math.cos(lat * Math.PI / 180) * Math.sin(seoulLat * Math.PI / 180) - Math.sin(lat * Math.PI / 180) * Math.cos(seoulLat * Math.PI / 180) * Math.cos(dLon);
      let bearingToSeoul = Math.atan2(y, x) * 180 / Math.PI;
      bearingToSeoul = (bearingToSeoul + 360) % 360;

      let angleDiff = Math.abs(coreAzimuth - bearingToSeoul);
      if (angleDiff > 180) angleDiff = 360 - angleDiff;

      let isSafe = true, statusColor = "", statusText = "";
      if (distance < 15) { isSafe = false; statusColor = "#f55"; statusText = `ğŸ”´ ë„ì‹¬ ë‚´ë¶€ (ì „ë°©ìœ„ ê´‘í•´)`; }
      else if (distance < 65 && angleDiff < 35) { isSafe = false; statusColor = "#f55"; statusText = `ğŸ”´ ì½”ì–´ ë°©í–¥ ê±°ëŒ€ ê´‘í•´`; }
      else if (distance < 90 && angleDiff < 45) { isSafe = true; statusColor = "#fa0"; statusText = `ğŸŸ¡ ì§€í‰ì„  ê´‘í•´ ì£¼ì˜`; }
      else { isSafe = true; statusColor = "#0df"; statusText = `ğŸŸ¢ ì½”ì–´ ë°©í–¥ ì–´ë‘ì›€`; }

      const bortleClass = distance < 15 ? 8 : (distance < 30 ? 6 : (distance < 50 ? 4 : (distance < 80 ? 3 : 2)));
      return { isSafe, statusColor, statusText, bortleClass, angleDiff, distance, bearingToSeoul };
    }

    function calcVisibilityScore({ coreAltDeg, moonEval, cloudEval, lpEval }){
      const alt = clamp(coreAltDeg, 0, 90);
      let altScore = 0;
      if(alt <= 0) altScore = 0;
      else if(alt < 15) altScore = (alt / 15) * 70;
      else if(alt < 30) altScore = 70 + ((alt - 15) / 15) * 15;
      else if(alt < 45) altScore = 85 + ((alt - 30) / 15) * 10;
      else altScore = 95 + Math.min(5, (alt - 45) / 45 * 5);

      let penalty = 0;
      if(!moonEval.isSafe){
        penalty += (moonEval.timelineColor === "#f00") ? 45 : 25;
      }
      if(cloudEval){
        if(!cloudEval.isSafe) penalty += 40;
        else if(cloudEval.statusColor === "#fa0") penalty += 12;
      } else {
        penalty += 8;
      }
      if(!lpEval.isSafe){
        penalty += (lpEval.statusColor === "#f55") ? 28 : 12;
      }

      let score = altScore - penalty;
      return Math.round(clamp(score, 0, 100));
    }

    function scoreToLabel(score){
      if(score >= 85) return { txt:"Sê¸‰ ì„ ëª… (ì¶”ì²œ)", col:"#0f0" };
      if(score >= 70) return { txt:"Aê¸‰ (ê´œì°®ìŒ)", col:"#0df" };
      if(score >= 50) return { txt:"Bê¸‰ (ë³´ì • ê°ì˜¤)", col:"#fd0" };
      if(score >= 30) return { txt:"Cê¸‰ (ë„ì „)", col:"#fa0" };
      return { txt:"Dê¸‰ (ë¹„ì¶”)", col:"#f55" };
    }

    function buildCompassSvgHtml(idPrefix, mwAzDeg){
      const mwArrowId = `${idPrefix}-mwArrow`;
      const navArrowId = `${idPrefix}-navArrow`;
      const navTextId = `${idPrefix}-navText`;

      return `
        <div class="card" style="margin-top:0;">
          <div class="row" style="align-items:flex-start;">
            <div style="flex:0 0 76px;">
              <svg width="76" height="76" viewBox="0 0 64 64" aria-label="ë‚˜ì¹¨ë°˜" style="display:block;">
                <defs>
                  <filter id="${idPrefix}-glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="2.2" result="blur"/>
                    <feMerge>
                      <feMergeNode in="blur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                </defs>
                <circle cx="32" cy="32" r="30" fill="rgba(255,255,255,0.03)" stroke="rgba(255,255,255,0.18)" stroke-width="1"/>
                <text x="32" y="12" text-anchor="middle" font-size="9" fill="#bbb" font-weight="800">N</text>
                <text x="54" y="35" text-anchor="middle" font-size="9" fill="#bbb" font-weight="800">E</text>
                <text x="32" y="58" text-anchor="middle" font-size="9" fill="#bbb" font-weight="800">S</text>
                <text x="10" y="35" text-anchor="middle" font-size="9" fill="#bbb" font-weight="800">W</text>
                <g id="${mwArrowId}" transform="rotate(${mwAzDeg} 32 32)" filter="url(#${idPrefix}-glow)">
                  <path d="M32 10 L38 30 L32 26 L26 30 Z" fill="#ff00ff"/>
                  <circle cx="32" cy="32" r="2.4" fill="#ff00ff"/>
                </g>
                <g id="${navArrowId}" transform="rotate(0 32 32)" filter="url(#${idPrefix}-glow)" opacity="0.0">
                  <path d="M32 12 L36 26 L32 23 L28 26 Z" fill="#0df"/>
                  <circle cx="32" cy="32" r="2.2" fill="#0df"/>
                </g>
              </svg>
            </div>
            <div style="flex:1; min-width:0;">
              <div style="font-weight:1000; font-size:14px; color:#fff;">
                ğŸ§­ ë°©í–¥:
                <span style="color:#ff77ff">${azToCompassKR(mwAzDeg)}</span>
                <span style="color:#aaa; font-weight:700;">(${Math.round(norm360(mwAzDeg))}Â°)</span>
              </div>
              <div class="muted" style="margin-top:6px;">
                ë³´ë¼ìƒ‰ í™”ì‚´í‘œ ìª½ì´ <b>ì½”ì–´ ë°©í–¥</b>ì…ë‹ˆë‹¤.
              </div>
              <div class="card" style="padding:8px; margin-top:10px;">
                <div class="row-between">
                  <div class="tiny">ì‹¤ì‹œê°„ ì•ˆë‚´</div>
                  <div class="tiny" id="${navTextId}" style="color:#0df; font-weight:900;">OFF</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function applyNavToPopup(idPrefix, mwAzDeg){
      const navArrow = document.getElementById(`${idPrefix}-navArrow`);
      const navText = document.getElementById(`${idPrefix}-navText`);
      if(!navArrow || !navText) return;

      if(!compassEnabled || lastHeadingDeg == null){
        navArrow.setAttribute("opacity", "0.0");
        navArrow.setAttribute("transform", "rotate(0 32 32)");
        navText.textContent = "OFF";
        navText.style.color = "#aaa";
        return;
      }

      const delta = signedDeltaDeg(mwAzDeg, lastHeadingDeg);
      const abs = Math.round(Math.abs(delta));
      navArrow.setAttribute("opacity", "1.0");
      navArrow.setAttribute("transform", `rotate(${delta} 32 32)`);

      if(abs < 5){
        navText.textContent = "ì •ë©´ âœ…";
        navText.style.color = "#0f0";
      } else {
        navText.textContent = (delta > 0) ? `ì˜¤ë¥¸ìª½ ${abs}Â°` : `ì™¼ìª½ ${abs}Â°`;
        navText.style.color = "#0df";
      }
    }

    function updatePopupNavIfAny(){
      if(window.__lastPopupCompassPrefix && lastMWAzDeg != null){
        applyNavToPopup(window.__lastPopupCompassPrefix, lastMWAzDeg);
      }
    }

    // =========================
    // Analyze / popup logic
    // =========================
    let analyzeSeq = 0;
    let marker = null, coreLine = null, currentLat = null, currentLng = null;

    // âœ… FIX: analyze fetch Abort
    let analyzeAbort = null;

    function findHourlyIndex(hourlyTimes, dateStr, hour){
      if (!Array.isArray(hourlyTimes)) return -1;
      const target = `${dateStr}T${pad2(hour)}:00`;
      return hourlyTimes.indexOf(target);
    }

    async function analyzeData(lat, lng, spotName=null){
      // âœ… ì´ì „ ë¶„ì„ ìš”ì²­ ì·¨ì†Œ
      if(analyzeAbort) analyzeAbort.abort();
      analyzeAbort = new AbortController();
      const { signal } = analyzeAbort;

      const mySeq = ++analyzeSeq;
      currentLat = lat; currentLng = lng;

      if (marker) map.removeLayer(marker);
      if (coreLine) map.removeLayer(coreLine);

      marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup("ë°ì´í„° ë¶„ì„ ì¤‘... ğŸ“¡").openPopup();

      const dateStr = document.getElementById('obs-date').value;
      const baseDate = parseLocalYMD(dateStr);

      const selectedHour = parseInt(document.getElementById('obs-time').value, 10);
      const selectedDate = new Date(baseDate);
      selectedDate.setHours(selectedHour, 0, 0, 0);

      const timelineStart = new Date(baseDate);
      timelineStart.setHours(18,0,0,0);

      // --- weather hourly for the day
      const withinWeather = isWithinWeatherWindow(dateStr);
      let weatherHourly = null;
      let isWeatherAvailable = false;
      let weatherWarningHtml = "";

      if(withinWeather){
        try{
          const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high,temperature_2m,dewpoint_2m,windspeed_10m&wind_speed_unit=ms&timezone=auto&start_date=${dateStr}&end_date=${dateStr}`;
          const response = await fetch(weatherUrl, { signal });
          if(response.ok){
            const weatherData = await response.json();
            if(weatherData.hourly && weatherData.hourly.time && weatherData.hourly.cloudcover){
              weatherHourly = weatherData.hourly;
              isWeatherAvailable = true;

              const idx = findHourlyIndex(weatherHourly.time, dateStr, selectedHour);
              if(idx >= 0){
                const temp = weatherHourly.temperature_2m[idx];
                const dew  = weatherHourly.dewpoint_2m[idx];
                const wind = weatherHourly.windspeed_10m[idx];
                weatherWarningHtml = `
                  <div class="card" style="margin-top:8px;">
                    <div class="tiny">ë‚ ì”¨ ê²½ê³ </div>
                    <div style="font-size:12px; margin-top:4px;">
                      <b>ğŸŒ¡ï¸ ê¸°ì˜¨/ì´ìŠ¬ì :</b> ${temp}Â°C / ${dew}Â°C &nbsp;ğŸ‘‰ ${(temp - dew) <= 2 ? '<span class="warning-text">ğŸ’§ ê²°ë¡œ ì£¼ì˜</span>' : '<span class="safe-text">âœ… ì•ˆì „</span>'}<br>
                      <div style="margin-top:2px;"><b>ğŸ’¨ í’ì†:</b> ${wind}m/s &nbsp;ğŸ‘‰ ${wind >= 5 ? '<span class="warning-text">âš ï¸ ê°•í’ ì£¼ì˜</span>' : '<span class="safe-text">âœ… ì•ˆì „</span>'}</div>
                    </div>
                  </div>
                `;
              }
            }
          }
        } catch(e){
          if(e && e.name === "AbortError") return;
          console.log("ê¸°ìƒ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨", e);
        }
      }

      function getCloudEvalForDate(d){
        if(!isWeatherAvailable || !weatherHourly) return null;
        const h = d.getHours();
        const idx = findHourlyIndex(weatherHourly.time, dateStr, h);
        if(idx < 0) return null;
        const cTotal = weatherHourly.cloudcover[idx];
        const cLow   = weatherHourly.cloudcover_low[idx];
        const cMid   = weatherHourly.cloudcover_mid[idx];
        const cHigh  = weatherHourly.cloudcover_high[idx];
        return { eval: evaluateCloudImpact(cLow, cMid, cHigh, cTotal), cTotal, cLow, cMid, cHigh };
      }

      // --- timeline bar
      let timelineBarHtml = '<div style="display:flex; width:100%; height:16px; border-radius:6px; overflow:hidden; margin:8px 0; border: 1px solid #555;">';
      let timelineLabelHtml = '<div style="display:flex; justify-content:space-between; color:#888; font-size:10px; padding:0 2px;">';

      for (let i=0;i<48;i++){
        const t = new Date(timelineStart.getTime() + i * 900000);
        const gc = getGalacticCorePosition(t, lat, lng);
        const moonEval = evaluateMoonImpact(t, lat, lng, gc.azimuth);
        let bg = '#222';
        if (gc.altitude > 0){
          if (gc.altitude < 15) bg = '#06a';
          else bg = moonEval.isSafe ? '#fd0' : moonEval.timelineColor;
        }
        timelineBarHtml += `<div style="flex:1; background:${bg};"></div>`;
      }
      timelineBarHtml += '</div>';
      for (let i=0;i<=12;i+=3){
        const tHour = (18 + i) % 24;
        timelineLabelHtml += `<span>${pad2(tHour)}h</span>`;
      }
      timelineLabelHtml += '</div>';

      // --- core/gold windows + best visibility time/window
      const simStartTime = new Date(baseDate); simStartTime.setHours(12,0,0,0);
      const simEndTime = new Date(simStartTime.getTime() + 24*60*60*1000);
      let coreStart=null, coreEnd=null;
      let goldStart=null, goldEnd=null;

      let bestVTime = null;
      let bestVScore = -1;
      let bestWindowStart = null, bestWindowEnd = null;

      for(let t=simStartTime.getTime(); t<simEndTime.getTime(); t += 10*60000){
        const tempD = new Date(t);
        const gc = getGalacticCorePosition(tempD, lat, lng);
        const moonEval = evaluateMoonImpact(tempD, lat, lng, gc.azimuth);

        if (gc.altitude > 0){
          if(!coreStart) coreStart = new Date(t);
          coreEnd = new Date(t);
        }
        if (gc.altitude >= 15 && moonEval.isSafe){
          if(!goldStart) goldStart = new Date(t);
          goldEnd = new Date(t);
        }
      }

      const scanStart = new Date(baseDate); scanStart.setHours(18,0,0,0);
      const scanEnd = new Date(scanStart.getTime() + 12*60*60*1000);

      for(let t=scanStart.getTime(); t<=scanEnd.getTime(); t += 20*60000){
        const d = new Date(t);
        const gc = getGalacticCorePosition(d, lat, lng);
        const moonEval = evaluateMoonImpact(d, lat, lng, gc.azimuth);
        const lpEval = evaluateDirectionalLightPollution(lat, lng, gc.azimuth);
        const cloudPack = getCloudEvalForDate(d);
        const cloudEval = cloudPack ? cloudPack.eval : null;

        const score = calcVisibilityScore({ coreAltDeg: gc.altitude, moonEval, cloudEval, lpEval });
        if(gc.altitude > 0 && score > bestVScore){
          bestVScore = score;
          bestVTime = new Date(d);
        }
      }

      if(bestVTime && bestVScore >= 0){
        const thresholdScore = Math.max(0, Math.round(bestVScore * 0.85));
        let inSeg = false;

        for(let t=scanStart.getTime(); t<=scanEnd.getTime(); t += 20*60000){
          const d = new Date(t);
          const gc = getGalacticCorePosition(d, lat, lng);
          if(gc.altitude < 15) { inSeg = false; continue; }

          const moonEval = evaluateMoonImpact(d, lat, lng, gc.azimuth);
          const lpEval = evaluateDirectionalLightPollution(lat, lng, gc.azimuth);
          const cloudPack = getCloudEvalForDate(d);
          const cloudEval = cloudPack ? cloudPack.eval : null;

          const score = calcVisibilityScore({ coreAltDeg: gc.altitude, moonEval, cloudEval, lpEval });
          if(score >= thresholdScore){
            if(!inSeg){
              inSeg = true;
              if(!bestWindowStart) bestWindowStart = new Date(d);
            }
            bestWindowEnd = new Date(d);
          } else {
            inSeg = false;
          }
        }
      }

      const fmtTime = (d)=> d ? `${pad2(d.getHours())}:${pad2(d.getMinutes())}` : null;
      const coreWinText = coreStart ? `${fmtTime(coreStart)} ~ ${fmtTime(coreEnd)}` : "ì‹œì¦Œ ì•„ë‹˜";
      const goldWinText = goldStart ? `${fmtTime(goldStart)} ~ ${fmtTime(goldEnd)}` : "ì¡°ê±´ ë¯¸ë‹¬";

      // --- selected time status
      const gcPos = getGalacticCorePosition(selectedDate, lat, lng);
      const moonEvalCurrent = evaluateMoonImpact(selectedDate, lat, lng, gcPos.azimuth);
      const lpEval = evaluateDirectionalLightPollution(lat, lng, gcPos.azimuth);

      let cloudEvalCurrent = null;
      let cTotal=0, cLow=0, cMid=0, cHigh=0;
      if(isWeatherAvailable && weatherHourly){
        const idx = findHourlyIndex(weatherHourly.time, dateStr, selectedHour);
        if(idx >= 0){
          cTotal = weatherHourly.cloudcover[idx];
          cLow   = weatherHourly.cloudcover_low[idx];
          cMid   = weatherHourly.cloudcover_mid[idx];
          cHigh  = weatherHourly.cloudcover_high[idx];
          cloudEvalCurrent = evaluateCloudImpact(cLow, cMid, cHigh, cTotal);
        }
      }

      const visibilityScore = calcVisibilityScore({
        coreAltDeg: gcPos.altitude,
        moonEval: moonEvalCurrent,
        cloudEval: cloudEvalCurrent,
        lpEval
      });
      const vLabel = scoreToLabel(visibilityScore);

      const az = norm360(gcPos.azimuth);
      lastMWAzDeg = az;

      if (gcPos.altitude > 0){
        const dist = 0.5;
        const endLat = lat + dist * Math.cos(az * Math.PI / 180);
        const endLng = lng + dist * Math.sin(az * Math.PI / 180) / Math.cos(lat * Math.PI / 180);
        coreLine = L.polyline([[lat,lng],[endLat,endLng]], { color:'#ff00ff', weight:4, dashArray:'5,10', opacity:0.8 }).addTo(map);
      }

      if (mySeq !== analyzeSeq) return;

      const isCoreSafe = (gcPos.altitude >= 10);
      let goTitle="", goBg="", goBorder="";
      if(isWeatherAvailable && cloudEvalCurrent){
        if(moonEvalCurrent.isSafe && cloudEvalCurrent.isSafe && isCoreSafe && lpEval.isSafe){
          goTitle="ğŸŸ¢ ë¬´ì¡°ê±´ GO! (ì§ ì‹¸ì„¸ìš”)"; goBg="rgba(0,255,100,0.2)"; goBorder="#0f0";
        } else if(!cloudEvalCurrent.isSafe || (!moonEvalCurrent.isSafe && moonEvalCurrent.statusColor==="#f55") || (!lpEval.isSafe && lpEval.statusColor==="#f55")){
          goTitle="ğŸ”´ NO-GO (ì§‘ì—ì„œ ë³´ì •í•˜ì„¸ìš”)"; goBg="rgba(255,50,50,0.2)"; goBorder="#f55";
        } else {
          goTitle="ğŸŸ¡ HOLD (ë¶€ë¶„ì  ê°„ì„­ / ëŒ€ê¸°)"; goBg="rgba(255,200,0,0.2)"; goBorder="#fa0";
        }
      } else {
        if(moonEvalCurrent.isSafe && isCoreSafe && lpEval.isSafe){
          goTitle="ğŸŸ¡ GO ê°€ëŠ¥ (ë‚ ì”¨ ë¯¸í™•ì¸)"; goBg="rgba(255,200,0,0.2)"; goBorder="#fd0";
        } else {
          goTitle="âšª ë°ì´í„° ë¶€ì¡±/ë¦¬ìŠ¤í¬ (ë‚ ì”¨ ëª¨ë¦„)"; goBg="rgba(150,150,150,0.2)"; goBorder="#aaa";
        }
      }

      const rCloud = (!cloudEvalCurrent)
        ? `ì•Œ ìˆ˜ ì—†ìŒ`
        : `<span><b style="color:${cloudEvalCurrent.statusColor}">${cloudEvalCurrent.statusText}</b> <span class="cloud-detail">(ìƒ${cHigh}%)</span></span>`;

      const rMoon = `<span><span style="font-size:16px; vertical-align:middle; margin-right:4px;">${moonEvalCurrent.moonEmoji}</span><b style="color:${moonEvalCurrent.statusColor}">${moonEvalCurrent.statusText}</b></span>`;
      const rCore = isCoreSafe ? `<span style="color:#0df">ê³ ë„ ${Math.round(gcPos.altitude)}Â°</span>` : `<span style="color:#f55">ê³ ë„ ${Math.round(gcPos.altitude)}Â° (ë‚®ìŒ)</span>`;
      const rLP   = `<span><b style="color:${lpEval.statusColor}">${lpEval.statusText}</b></span>`;
      const titleHtml = spotName ? `<b>ğŸ“ ${escapeHtml(spotName)}</b><br>` : `<b>ğŸ“ ê´€ì¸¡ í›„ë³´ì§€</b> (${lat.toFixed(3)}, ${lng.toFixed(3)})<br>`;
      const safeSpotName = spotName ? spotName.replace(/'/g, "\\'") : '';

      const compassPrefix = `cmp${Date.now()}${Math.floor(Math.random()*1000)}`;
      window.__lastPopupCompassPrefix = compassPrefix;
      const compassHtml = buildCompassSvgHtml(compassPrefix, az);

      const bestTimeText = bestVTime ? `${fmtTime(bestVTime)} (ì ìˆ˜ ${bestVScore}/100)` : "ê³„ì‚° ë¶ˆê°€";
      const bestWindowText = (bestWindowStart && bestWindowEnd)
        ? `${fmtTime(bestWindowStart)} ~ ${fmtTime(bestWindowEnd)}`
        : "ì¡°ê±´ ë¯¸ë‹¬";

      const visibilityBox = `
        <div class="mw-window-box" style="margin-top:10px; padding:10px;">
          <div class="row-between">
            <div style="font-size:14px; font-weight:1000; color:#fff;">âœ¨ ì€í•˜ìˆ˜ ì„ ëª…ë„</div>
            <div style="font-weight:1000; color:${vLabel.col};">${visibilityScore}/100</div>
          </div>
          <div style="margin-top:4px; color:${vLabel.col}; font-weight:1000;">${vLabel.txt}</div>
        </div>
      `;

      const timelineContent = `
        <div class="mw-window-box" style="margin-bottom:0; border:none; background:transparent; padding:0;">
          <div style="font-weight:1000; color:#fff; text-align:center; margin-bottom:6px;">ğŸŒŒ Milky Way Window</div>
          ${timelineBarHtml}
          ${timelineLabelHtml}
          <div class="timeline-legend">
            <div class="legend-item"><div class="legend-box" style="background:#06a;"></div>ì½”ì–´ ë‚®ìŒ</div>
            <div class="legend-item"><div class="legend-box" style="background:#635;"></div>ë‹¬ ì”»ê¹€</div>
            <div class="legend-item"><div class="legend-box" style="background:#c60;"></div>ì €ê³ ë„ë‹¬</div>
            <div class="legend-item"><div class="legend-box" style="background:#f00;"></div>ë‹¬ ê²¹ì¹¨</div>
            <div class="legend-item"><div class="legend-box" style="background:#fd0;"></div><b style="color:#fd0;">ìœ ë¦¬(ê³ ë„15Â°â†‘)</b></div>
          </div>
          <hr style="border-top:1px dashed #555; margin:10px 0;">
          <div style="font-size:12px; color:#ddd; line-height:1.45; text-align:center;">
            <b>ì¶”ì²œ ë² ìŠ¤íŠ¸ íƒ€ì„:</b> <span style="color:#0df; font-weight:1000;">${bestTimeText}</span><br>
            <div style="margin-top:4px;"><b>ì¶”ì²œ ì‹œê°„ëŒ€:</b> <span style="color:#fd0; font-weight:1000;">${bestWindowText}</span></div>
          </div>
        </div>
      `;

      let popupText = `
        <div style="font-size: 13px; line-height: 1.6; padding-bottom:5px;">
          ${titleHtml}
          <span style="color:#aaa; font-size:11px;">ê¸°ì¤€ ì‹œê°„: ${dateStr} ${pad2(selectedHour)}:00</span><br>

          ${visibilityBox}

          <div class="gonogo-box" style="background:${goBg}; border:1px solid ${goBorder}; margin-top:8px;">
            <div class="gonogo-title" style="color:${goBorder}">${goTitle}</div>
            <div class="gonogo-item"><span>ğŸŒ™ <b>ë‹¬ ëª¨ì–‘:</b></span> ${rMoon}</div>
            <div class="gonogo-item"><span>â˜ï¸ <b>êµ¬ë¦„:</b></span> ${rCloud}</div>
            <div class="gonogo-item"><span>ğŸŒŒ <b>ì½”ì–´ ê³ ë„:</b></span> ${rCore}</div>
            <div class="gonogo-item"><span>ğŸ’¡ <b>ê´‘í•´ë°©í–¥:</b></span> ${rLP}</div>
          </div>

          ${(isWeatherAvailable && weatherWarningHtml) ? weatherWarningHtml : ''}

          <details class="popup-details">
            <summary class="popup-summary">ğŸŒŒ ì€í•˜ìˆ˜ íƒ€ì„ë¼ì¸ ë³´ê¸°</summary>
            <div class="popup-details-content">
              ${timelineContent}
            </div>
          </details>

          <details class="popup-details">
            <summary class="popup-summary">ğŸ§­ ì€í•˜ìˆ˜ ë°©í–¥ ë° ë‚˜ì¹¨ë°˜</summary>
            <div class="popup-details-content">
              ${compassHtml}
            </div>
          </details>

          <details class="popup-details">
            <summary class="popup-summary">ğŸ“· í”„ë ˆì´ë° ê°€ì´ë“œ (í™”ê°)</summary>
            <div class="popup-details-content">
              ${getFovSummaryHtml()}
            </div>
          </details>

          <button class="btn-capture" onclick="capturePopup(event, this)">ğŸ“¸ ê²°ê³¼ ìº¡ì²˜í•˜ì—¬ ì €ì¥í•˜ê¸°</button>
          <button class="btn-favorite" onclick="saveFavorite(event, ${lat}, ${lng}, '${safeSpotName}')">â­ ì´ ì¥ì†Œ ì¦ê²¨ì°¾ê¸°ì— ì €ì¥</button>
        </div>
      `;

      marker.bindPopup(popupText).openPopup();

      const popupNode = marker.getPopup().getElement();
      if(popupNode) {
        const detailsElements = popupNode.querySelectorAll('details');
        detailsElements.forEach(d => {
          d.addEventListener('toggle', () => {
            marker.getPopup().update();
          });
        });
      }

      applyNavToPopup(compassPrefix, az);
      updateCompassPanelUI();
    }

    window.capturePopup = function(ev, btnElement) {
      if (ev) { ev.preventDefault(); ev.stopPropagation(); }

      const popupEl = document.querySelector('.leaflet-popup');
      if (!popupEl) return;

      popupEl.addEventListener('click', (e) => { e.stopPropagation(); }, { once: true });

      const originalText = btnElement.innerText;
      btnElement.innerText = "â³ ì´ë¯¸ì§€ ì €ì¥ ì¤‘...";
      btnElement.style.pointerEvents = "none";

      html2canvas(popupEl, {
        backgroundColor: "#1e1e1e",
        scale: 2,
        useCORS: true
      }).then(canvas => {
        const dateStr = document.getElementById('obs-date').value;
        const link = document.createElement('a');
        link.download = `MilkyWay_ê²°ê³¼_${dateStr}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();

        btnElement.innerText = originalText;
        btnElement.style.pointerEvents = "auto";
      }).catch(err => {
        alert("ì´ë¯¸ì§€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        btnElement.innerText = originalText;
        btnElement.style.pointerEvents = "auto";
        console.error(err);
      });
    };

    // =========================
    // Best date (new moon-ish)
    // =========================
    function calculateBestDate(){
      let bestDate=null, minFraction=1.0, bestEmoji="ğŸŒ‘";
      for(let i=0;i<=30;i++){
        const testD = new Date();
        testD.setDate(testD.getDate() + i);
        testD.setHours(12,0,0,0);
        const moon = SunCalc.getMoonIllumination(testD);
        if(moon.fraction < minFraction){
          minFraction = moon.fraction;
          bestDate = testD;
          bestEmoji = getMoonPhaseEmoji(moon.phase);
        }
      }
      if(bestDate){
        const bY = bestDate.getFullYear(), bM = pad2(bestDate.getMonth()+1), bD = pad2(bestDate.getDate());
        const bestStr = `${bY}-${bM}-${bD}`;
        document.getElementById('best-date-box').innerHTML = `
          <div style="font-size:16px; font-weight:1000; color:#0df;">${bY}ë…„ ${bM}ì›” ${bD}ì¼</div>
          <div style="font-size:13px; color:#aaa; margin-top:4px;">${bestEmoji} ì˜ˆìƒ ë‹¬ë¹›: ${Math.round(minFraction*100)}%</div>
          <div class="tiny" style="margin-top:6px; color:#777;">í´ë¦­í•˜ì—¬ ë‚ ì§œ ì ìš©</div>
        `;
        document.getElementById('best-date-box').style.cursor = "pointer";
        document.getElementById('best-date-box').onclick = function(){
          document.getElementById('obs-date').value = bestStr;
          updateWeatherModeUI();
          if(currentLat!=null) analyzeData(currentLat, currentLng);
        };
      }
    }
    calculateBestDate();

    // =========================
    // Candidate spots simulation
    // =========================
    const candidateSpots = [
      { name: "ì—°ì²œ ë‹¹í¬ì„± (ê²½ê¸° ë¶ë¶€)", lat: 38.013, lng: 126.949 },
      { name: "íŒŒì£¼ ê°ì•…ì‚° ë¶€ê·¼ (ê²½ê¸° ë¶ë¶€)", lat: 37.942, lng: 126.960 },
      { name: "ì–‘í‰ ë²—ê³ ê°œ (ê²½ê¸° ë™ë¶€)", lat: 37.534, lng: 127.387 },
      { name: "ê°•ë¦‰ ì•ˆë°˜ë°ê¸° (ê°•ì› ì˜ë™)", lat: 37.615, lng: 128.823 },
      { name: "í™”ì²œ ì¡°ê²½ì² ì²œë¬¸ëŒ€ (ê°•ì› ì˜ì„œ)", lat: 38.125, lng: 127.461 },
      { name: "íƒœë°± ë§¤ë´‰ì‚° ë°”ëŒì˜ì–¸ë• (ê°•ì›)", lat: 37.218, lng: 128.981 },
      { name: "í•©ì²œ í™©ë§¤ì‚° (ê²½ë‚¨)", lat: 35.582, lng: 127.975 },
      { name: "ë¶€ì—¬ ì‚¬ë‘ë‚˜ë¬´ (ì¶©ë‚¨)", lat: 36.257, lng: 126.903 }
    ];

    document.getElementById('btn-simulate').addEventListener('click', async function(){
      const btn = this;
      const msg = document.getElementById('simulate-msg');
      const targetDate = document.getElementById('obs-date').value;
      const progContainer = document.getElementById('progress-container');
      const progBar = document.getElementById('progress-bar');

      if(!isWithinWeatherWindow(targetDate)){
        msg.style.display='block'; msg.style.color='#fd0';
        msg.innerText='âš ï¸ 14ì¼ ì´í›„ëŠ” ë‚ ì”¨ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜ ë¶ˆê°€(ë‹¬/ê´‘í•´/ì½”ì–´ë§Œ í™•ì¸í•˜ì„¸ìš”).';
        return;
      }

      btn.disabled = true;
      msg.style.display = 'block';
      msg.style.color = '#0df';
      msg.innerText = "êµ­ë‚´ ì£¼ìš” ëª…ì†Œë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤.";
      progContainer.style.display = 'block';
      progBar.style.width = '0%';

      let bestScore = -1, bestSpot = null, bestHour = 22;
      const searchHours = [0,1,2,3,4,20,21,22,23];

      try{
        for(let i=0; i<candidateSpots.length; i++){
          const spot = candidateSpots[i];

          const percentage = Math.round(((i + 1) / candidateSpots.length) * 100);
          btn.innerHTML = `ğŸ“¡ ë¶„ì„ ì¤‘... (${percentage}%)`;
          progBar.style.width = `${percentage}%`;
          await new Promise(r => setTimeout(r, 50));

          const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${spot.lat}&longitude=${spot.lng}&hourly=cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high&timezone=auto&start_date=${targetDate}&end_date=${targetDate}`;
          const response = await fetch(weatherUrl);
          if(!response.ok) continue;

          const weatherData = await response.json();
          if(!weatherData.hourly || !weatherData.hourly.cloudcover || !weatherData.hourly.time) continue;

          for(const h of searchHours){
            const idx = findHourlyIndex(weatherData.hourly.time, targetDate, h);
            if (idx < 0) continue;

            const cTotal = weatherData.hourly.cloudcover[idx];
            const cLow   = weatherData.hourly.cloudcover_low[idx];
            const cMid   = weatherData.hourly.cloudcover_mid[idx];
            const cHigh  = weatherData.hourly.cloudcover_high[idx];

            const d = parseLocalYMD(targetDate); d.setHours(h,0,0,0);
            const gcPos = getGalacticCorePosition(d, spot.lat, spot.lng);
            const moonEval = evaluateMoonImpact(d, spot.lat, spot.lng, gcPos.azimuth);
            const cloudEval = evaluateCloudImpact(cLow, cMid, cHigh, cTotal);
            const lpEval = evaluateDirectionalLightPollution(spot.lat, spot.lng, gcPos.azimuth);

            let score = 100 - (cTotal * 0.4) - (cLow * 0.2) - (cMid * 0.4) - (cHigh * 1.5) - ((lpEval.bortleClass - 1) * 8);

            if(!moonEval.isSafe) score -= 30;
            if(moonEval.timelineColor === "#f00") score -= 60;
            if(!cloudEval.isSafe) score -= 50;
            if(!lpEval.isSafe) score -= 40;
            if(gcPos.altitude <= 0) score -= 40;

            if(score > bestScore){ bestScore = score; bestSpot = spot; bestHour = h; }
          }
        }

        if(bestSpot && bestScore > 0){
          document.getElementById('obs-time').value = bestHour;
          document.getElementById('time-text').innerText = `${pad2(bestHour)}:00`;
          msg.style.color = "#0df";
          msg.innerText = `âœ… [${bestSpot.name}] ${bestHour}ì‹œê°€ ê°€ì¥ ìµœì ì…ë‹ˆë‹¤!`;
          map.setView([bestSpot.lat, bestSpot.lng], 11);
          analyzeData(bestSpot.lat, bestSpot.lng, bestSpot.name);
          if(window.innerWidth <= 768) document.getElementById('ui-panel').classList.add('collapsed');
        } else {
          msg.style.color = "#f55";
          msg.innerText = "âŒ ê¸°ìƒ ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ì¡°ê±´ì´ ë§ëŠ” ê³³ì´ ì—†ìŠµë‹ˆë‹¤.";
        }
      } catch(err){
        msg.style.color = "#f55";
        msg.innerText = "ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
        console.log(err);
      } finally {
        btn.disabled = false;
        btn.innerHTML = "ğŸš€ ì„ íƒí•œ ë‚ ì§œì˜ ìµœì ì§€ ì°¾ê¸°";
        setTimeout(() => { progContainer.style.display = 'none'; }, 1000);
      }
    });

    // =========================
    // UI controls
    // =========================
    document.getElementById('map-theme').addEventListener('change', function(e){
      map.removeLayer(currentBaseLayer);
      currentBaseLayer = e.target.value === 'dark' ? darkLayer : (e.target.value === 'satellite' ? satelliteLayer : standardLayer);
      currentBaseLayer.addTo(map);
    });

    document.getElementById('light-pollution-toggle').addEventListener('change', function(e){
      e.target.checked ? lightPollutionLayer.addTo(map) : map.removeLayer(lightPollutionLayer);
    });

    document.getElementById('lp-opacity').addEventListener('input', function(e){
      lightPollutionLayer.setOpacity(e.target.value);
      document.getElementById('opacity-val').innerText = Math.round(e.target.value * 100);
    });

    document.getElementById('btn-today').addEventListener('click', function(){
      document.getElementById('obs-date').value = fmtYMD(getToday());
      updateWeatherModeUI();
      if(currentLat!=null) analyzeData(currentLat, currentLng);
    });

    document.getElementById('obs-time').addEventListener('input', function(e){
      document.getElementById('time-text').innerText = `${pad2(e.target.value)}:00`;
    });

    document.getElementById('obs-time').addEventListener('change', function(){
      if(currentLat!=null) analyzeData(currentLat, currentLng);
    });

    document.getElementById('obs-date').addEventListener('change', function(){
      updateWeatherModeUI();
      if(currentLat!=null) analyzeData(currentLat, currentLng);
      const m = document.getElementById('simulate-msg');
      if(isWithinWeatherWindow(document.getElementById('obs-date').value)){ m.style.display='none'; }
    });

    // Map click
    map.on('click', function(e){ analyzeData(e.latlng.lat, e.latlng.lng); });

    updateWeatherModeUI();
  </script>
</body>
</html>